# 3.1
# 1. 2. 3. 4.
# Задача HashTable
class HashTable:
    def __init__(self, sz, stp):
        self.size = sz #размер хэш-таблицы
        self.step = stp #длина шага (количество слотов) для поиска следующего свободного слота
        self.slots = [None] * self.size 

    def hash_fun(self, value):
	'''
	расчитывает и возвращает корректный индекс слота
	'''
        return sum(value.encode()) % self.size

    def seek_slot(self, value):
	'''
	1. по входному значению производится расчет индекса хэш-функцией  
	2. производится поиск подходящего слота с учётом коллизий 
	возвращает None, если не удалось подобрать слот
	'''
        slot = self.hash_fun(value)
        count = 0
        while self.slots[slot] is not None and count < self.size:
            slot += self.step
        #...code      

# 5. 6. 7.
# Задача PowerSet
class PowerSet:
    #...code  
    def intersection(self, set2):
	'''
	возвращается пересечение текущего множества и переданного в качестве параметра
	т.е. элементы, которые есть в обоих множествах
	'''
        result_set = PowerSet()
        for i in self.set:
            if set2.get(i):
                result_set.put(i)
        return result_set

    def union(self, set2):
	'''	
        производится объединение текущего множества и переданного в качестве параметра
	'''
        result_set = PowerSet()
        for i in self.set:
            result_set.put(i)
        for j in set2.set:
            result_set.put(j)
        return result_set

    def difference(self, set2):
	'''	
	возвращается разница между текущим множеством и переданным в качестве параметра
	т.е. те элементы текущего множества, которые не входят в множество-параметр
	'''
        result_set = PowerSet()
        for i in self.set:
            if set2.get(i) is False:
                result_set.put(i)
        return result_set

    
# 3.2
# Курс на Python с нуля задание 8.8
# Все комментарии избыточны и от них следует избавиться

# Было
# фиксируем в переменных первоначальное содержание горшков
a = 'герань '
b = 'фиалки '
c = 'кактус '
# демонстрируем первоначальную позицию
print("Положение горшков в первый день: ", a+b+c)
# запрашиваем ввод проверяемого значения
days_left = int(input('Введите число дней для проверки положения горшков: '))
for i in range(days_left):
    a, b, c = c, a, b # с помощью операции множественного присваивания имитируем перестановку горшков за день
# демонстрируем результирующее положение горшков
print("Положение горшков в через несколько дней: ", a+b+c)

# Результат
a = 'герань '
b = 'фиалки '
c = 'кактус '

print("Положение горшков в первый день: ", a+b+c)

days_left = int(input('Введите число дней для проверки положения горшков: '))
for i in range(days_left):
    a, b, c = c, a, b 

print("Положение горшков в через несколько дней: ", a+b+c)


# Курс на Python с нуля задание 8.9
# Все комментарии избыточны и от них следует избавиться

# Было
# вводим значение для расчета
num = int(input('Введите для какого числа будем расчитывать факториал: '))
#запускаем цикл на требуемое количество раз
if num > 100000 or num >= 0:
    f = 1
    for i in range(2, num+1):
        f *= i
    print('Факториал числа', num, 'равен', f)
else:
    print('Вы ввели либо слишком большое значение, либо отрицательное.')


# Результат
num = int(input('Введите для какого числа будем расчитывать факториал: '))
if num > 100000 or num >= 0:
    f = 1
    for i in range(2, num+1):
        f *= i
    print('Факториал числа', num, 'равен', f)
else:
    print('Вы ввели либо слишком большое значение, либо отрицательное.')